#!KAMAILIO

# CallStack Kamailio Configuration
# SIP Proxy for WebRTC to PSTN integration

####### Global Parameters #########

#!define WITH_WEBSOCKET
#!define WITH_TLS
#!define WITH_AUTH
#!define WITH_NAT
#!define WITH_PRESENCE
#!define WITH_ALIASDB
#!define WITH_USRLOCDB
#!define WITH_RTPENGINE

# Debug level (stdout log)
debug=3
log_stderror=yes
log_facility=LOG_LOCAL0
fork=yes
children=4

# IP address to listen on
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=tls:0.0.0.0:5061
listen=websocket:0.0.0.0:8080

# TLS configuration
#!ifdef WITH_TLS
enable_tls=yes
tls_method=TLSv1.2
tls_verify_server=0
tls_verify_client=0
tls_require_client_certificate=0
#!endif

# Database connection
#!ifdef WITH_USRLOCDB
# SQLite database for user location and authentication
modparam("sqlops", "dbcon", "ca=>sqlite:///var/lib/kamailio/kamailio.db")
#!endif

####### Modules Section ########

# Standard modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"

# Database modules
#!ifdef WITH_USRLOCDB
loadmodule "sqlops.so"
loadmodule "uid_auth_db.so"
loadmodule "uid_domain.so"
loadmodule "uid_gflags.so"
loadmodule "uid_uri_db.so"
#!endif

# WebSocket support
#!ifdef WITH_WEBSOCKET
loadmodule "websocket.so"
loadmodule "nathelper.so"
#!endif

# TLS support
#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

# NAT traversal
#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
#!endif

# Presence
#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
loadmodule "pua.so"
loadmodule "pua_dialoginfo.so"
loadmodule "rls.so"
#!endif

# RTP Engine for media handling
#!ifdef WITH_RTPENGINE
loadmodule "rtpengine.so"
#!endif

####### Routing Logic ########

# SIP request routing
request_route {
    # Sanity checks
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if (is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }

    if (!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        } else {
            sl_reply_error();
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    if (has_totag()) {
        # sequential request withing a dialog should
        # take the path determined by record-routing
        if (loose_route()) {
            if (is_method("BYE")) {
                setflag(FLT_ACC); # do accounting ...
                setflag(FLT_ACCFAILED); # ... even if the transaction fails
            } else if ( is_method("INVITE") ) {
                # even if in-dialog to-do INVITE for re-INVITEs
                route(WITHINDLG);
            } else if ( is_method("NOTIFY") ) {
                # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
                record_route();
            }
            route(RELAY);
            exit;
        }

        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        sl_send_reply("404", "Not here");
        exit;
    }

    #initial requests
    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans())
            route(RELAY);
        exit;
    }

    t_check_trans();

    # Handle presence
    if (is_method("PUBLISH") || is_method("SUBSCRIBE")) {
        route(PRESENCE);
        exit;
    }

    # Handle registrations
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # NAT detection
    route(NATDETECT);

    # Authentication
    if (is_method("INVITE") || is_method("MESSAGE")) {
        route(AUTH);
    }

    # Record routing for dialog forming requests (in case they are routed)
    if (is_method("INVITE") || is_method("SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(FLT_ACC); # do accounting
    }

    # Dispatch requests to foreign domains
    route(SIPOUT);

    ### request for local domain
    if (is_myhost("$rd")) {
        # WebRTC to SIP gateway
        if (has_body("application/sdp")) {
            route(RTPENGINE);
        }

        # User location service
        route(LOCATION);
    }

    # Send to foreign domain
    route(SIPOUT);

    # No destination found
    sl_send_reply("404", "Not Found");
    exit;
}

# Wrapper for relaying requests
route[RELAY] {
    # enable additional event routes for forwarded requests
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per SIP request initial checks
route[REQINIT] {
    if($ua=~"friendly-scanner|sipcli|VaxSIPUserAgent") {
        sl_send_reply("200", "OK");
        exit;
    }

    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# Handle SIP registrations
route[REGISTRAR] {
    if (!is_myhost("$rd")) {
        sl_send_reply("403", "Forbidden");
        exit;
    }

    # Authentication
    if (www_authenticate("$fd", "subscriber")) {
        auth_challenge("$fd", "0");
        exit;
    }

    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# User location service
route[LOCATION] {
    if (!lookup("location")) {
        $var(rc) = $rc;
        route(TOVOICEMAIL);
        t_newtran();
        switch ($var(rc)) {
            case -1:
            case -3:
                send_reply("404", "Not Found");
                exit;
            case -2:
                send_reply("405", "Method Not Allowed");
                exit;
        }
    }

    # when routing via usrloc, log the missed calls also
    if (is_method("INVITE")) {
        setflag(FLT_ACCMISSED);
    }

    route(RELAY);
    exit;
}

# Presence server processing
route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE")) {
        sl_send_reply("404", "Not here");
        exit;
    }

    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }

    if(is_method("PUBLISH")) {
        handle_publish();
        t_release();
    } else if( is_method("SUBSCRIBE")) {
        handle_subscribe();
        t_release();
    }

    exit;
}

# IP authorization and user authentication
route[AUTH] {
    if (is_method("REGISTER") || from_uri==myself) {
        # Authenticate requests from local users
        if (!auth_check("$fd", "subscriber", "1")) {
            auth_challenge("$fd", "0");
            exit;
        }
    } else {
        # Foreign domain requests - authenticate if required
        if (auth_check("$fd", "subscriber", "0")) {
            auth_challenge("$fd", "0");
            exit;
        }
    }
    # user authenticated - remove auth header
    if(!is_method("REGISTER|PUBLISH"))
        consume_credentials();
}

# Caller NAT detection
route[NATDETECT] {
    # Force rport, for NAT traversal
    force_rport();

    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(FLT_NATS);
    }
    return;
}

# RTP proxy management
route[RTPENGINE] {
    # RTPengine configuration
    if (has_body("application/sdp")) {
        if (rtpengine_manage("replace-origin replace-session-connection ICE=force")) {
            xlog("RTPengine managed\n");
        } else {
            xlog("RTPengine failed\n");
            send_reply("500", "Server Error");
            exit;
        }
    }
}

# XMLRPC routing
route[XMLRPC] {
    # allow XMLRPC from localhost
    if ((method=="POST" || method=="GET")
            && (src_ip==127.0.0.1)) {
        # close connection only for xmlrpclib user agents (there is a bug in
        # xmlrpclib: it waits for EOF before interpreting the response).
        if ($hdr(User-Agent) =~ "xmlrpclib")
            set_reply_close();
        set_reply_no_connect();
        dispatch_rpc();
        exit;
    }
    send_reply("403", "Forbidden");
    exit;
}

# Voicemail routing
route[TOVOICEMAIL] {
    if(!is_method("INVITE|SUBSCRIBE"))
        return;

    # check if VoiceMail server IP is defined
    if (strempty($avp(s:voicemail_server))) {
        xlog("VoiceMail server not defined\n");
        return;
    }

    # only redirect the Voicemail server
    if($avp(s:voicemail_server)!=$rd)
        return;

    # rewrite R-URI
    rewritehostport("voicemail.example.com:5060");

    # route to the voicemail server
    route(RELAY);
    exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
    return;
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xdbg("incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;

    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
}

# NAT management
route[NATMANAGE] {
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB)))
        return;

    if (is_request()) {
        if(has_totag()) {
            if(is_method("BYE")) {
                setflag(FLT_ACC);
            }
        }
    }

    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB)))
        return;

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(FLB_NATB)) {
            if(is_first_hop())
                set_contact_alias();
        }
    }
}

# SIP outbound handling
route[SIPOUT] {
    if (uri==myself) return;

    append_hf("P-hint: outbound\r\n");
    route(RELAY);
    exit;
}